<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Edge node: tesst.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Edge node
   &#160;<span id="projectnumber">3.0</span>
   </div>
   <div id="projectbrief">A C library for parsing HTML.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_5c982d53a68cdbcd421152b4020263a9.html">main</a></li><li class="navelem"><a class="el" href="dir_bad007344d42f4b5340fab5412b591e5.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tesst.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;driver/periph_ctrl.h&quot;</code><br />
<code>#include &quot;esp_err.h&quot;</code><br />
<code>#include &quot;esp_intr_alloc.h&quot;</code><br />
<code>#include &quot;freertos/FreeRTOS.h&quot;</code><br />
<code>#include &quot;freertos/queue.h&quot;</code><br />
<code>#include &quot;freertos/ringbuf.h&quot;</code><br />
<code>#include &quot;freertos/semphr.h&quot;</code><br />
<code>#include &quot;freertos/task.h&quot;</code><br />
<code>#include &quot;freertos/xtensa_api.h&quot;</code><br />
<code>#include &quot;soc/uart_caps.h&quot;</code><br />
<code>#include &quot;soc/uart_periph.h&quot;</code><br />
<code>#include &lt;esp_types.h&gt;</code><br />
</div>
<p><a href="tesst_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuart__config__t.html">uart_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART configuration parameters for uart_param_config function.  <a href="structuart__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuart__intr__config__t.html">uart_intr_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART interrupt configuration parameters for uart_intr_config function.  <a href="structuart__intr__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuart__event__t.html">uart_event_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event structure used in UART event queue.  <a href="structuart__event__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a653fc44b41db6efb3884c15ce8d6c30e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a653fc44b41db6efb3884c15ce8d6c30e">UART_FIFO_LEN</a>&#160;&#160;&#160;(128)</td></tr>
<tr class="separator:a653fc44b41db6efb3884c15ce8d6c30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236e4265357229fa5f9b586cc744866d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a236e4265357229fa5f9b586cc744866d">UART_INTR_MASK</a>&#160;&#160;&#160;0x1ff</td></tr>
<tr class="separator:a236e4265357229fa5f9b586cc744866d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7652c930ed7eb1841c38419905e5eafd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a7652c930ed7eb1841c38419905e5eafd">UART_LINE_INV_MASK</a>&#160;&#160;&#160;(0x3f &lt;&lt; 19)</td></tr>
<tr class="separator:a7652c930ed7eb1841c38419905e5eafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5636b7aad11849ee4c6f7c481dc07f6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#ab5636b7aad11849ee4c6f7c481dc07f6">UART_BITRATE_MAX</a>&#160;&#160;&#160;5000000</td></tr>
<tr class="separator:ab5636b7aad11849ee4c6f7c481dc07f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33b16f9bc23412d5d31f76d134a36db"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#ab33b16f9bc23412d5d31f76d134a36db">UART_PIN_NO_CHANGE</a>&#160;&#160;&#160;(-1)</td></tr>
<tr class="separator:ab33b16f9bc23412d5d31f76d134a36db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683885aa03c7b605604d897e27cb5355"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a683885aa03c7b605604d897e27cb5355">UART_INVERSE_DISABLE</a>&#160;&#160;&#160;(0x0)</td></tr>
<tr class="separator:a683885aa03c7b605604d897e27cb5355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12becc6acce13974ed835c4e67bbfa6e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a12becc6acce13974ed835c4e67bbfa6e">UART_INVERSE_RXD</a>&#160;&#160;&#160;(UART_RXD_INV_M)</td></tr>
<tr class="separator:a12becc6acce13974ed835c4e67bbfa6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890cb40955ca53d14b6d92fca06ae9c4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a890cb40955ca53d14b6d92fca06ae9c4">UART_INVERSE_CTS</a>&#160;&#160;&#160;(UART_CTS_INV_M)</td></tr>
<tr class="separator:a890cb40955ca53d14b6d92fca06ae9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda3c509c62bcca3bf7aae18218fb524"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#acda3c509c62bcca3bf7aae18218fb524">UART_INVERSE_TXD</a>&#160;&#160;&#160;(UART_TXD_INV_M)</td></tr>
<tr class="separator:acda3c509c62bcca3bf7aae18218fb524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930be76712b1217fba81c9cd541d532a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a930be76712b1217fba81c9cd541d532a">UART_INVERSE_RTS</a>&#160;&#160;&#160;(UART_RTS_INV_M)</td></tr>
<tr class="separator:a930be76712b1217fba81c9cd541d532a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3f041e20057aa29e3733adba8e84b484"><td class="memItemLeft" align="right" valign="top"><a id="a3f041e20057aa29e3733adba8e84b484"></a>
typedef intr_handle_t&#160;</td><td class="memItemRight" valign="bottom"><b>uart_isr_handle_t</b></td></tr>
<tr class="separator:a3f041e20057aa29e3733adba8e84b484"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a93f7c73d772490ab4d22bda8fd0aa5a6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a93f7c73d772490ab4d22bda8fd0aa5a6">uart_mode_t</a> { <br />
&#160;&#160;<a class="el" href="tesst_8h.html#a93f7c73d772490ab4d22bda8fd0aa5a6a068436d1319f7158782d371df48a7651">UART_MODE_UART</a> = 0x00, 
<a class="el" href="tesst_8h.html#a93f7c73d772490ab4d22bda8fd0aa5a6a40e580a730e4271d4731437a0db660e5">UART_MODE_RS485_HALF_DUPLEX</a>, 
<a class="el" href="tesst_8h.html#a93f7c73d772490ab4d22bda8fd0aa5a6adc56553dfc0f8e278433c0f2fcf45ecc">UART_MODE_IRDA</a> = 0x02, 
<a class="el" href="tesst_8h.html#a93f7c73d772490ab4d22bda8fd0aa5a6a59417d152f9453f44081584bc16feb88">UART_MODE_RS485_COLLISION_DETECT</a>, 
<br />
&#160;&#160;<a class="el" href="tesst_8h.html#a93f7c73d772490ab4d22bda8fd0aa5a6aac2905a4d8c52542451b87d4f7986fce">UART_MODE_RS485_APP_CTRL</a> = 0x04
<br />
 }<tr class="memdesc:a93f7c73d772490ab4d22bda8fd0aa5a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART mode selection.  <a href="tesst_8h.html#a93f7c73d772490ab4d22bda8fd0aa5a6">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a93f7c73d772490ab4d22bda8fd0aa5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab50969c4f0a2257304e7e88016b0044"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#aab50969c4f0a2257304e7e88016b0044">uart_word_length_t</a> { <br />
&#160;&#160;<a class="el" href="tesst_8h.html#aab50969c4f0a2257304e7e88016b0044a45437f3ff3941ae72e531dfb755456f4">UART_DATA_5_BITS</a> = 0x0, 
<a class="el" href="tesst_8h.html#aab50969c4f0a2257304e7e88016b0044a2f062e3e06c3560077fe86fef6b8d9cb">UART_DATA_6_BITS</a> = 0x1, 
<a class="el" href="tesst_8h.html#aab50969c4f0a2257304e7e88016b0044aa5bd9a1dad740644b4c60fe0a8f9addd">UART_DATA_7_BITS</a> = 0x2, 
<a class="el" href="tesst_8h.html#aab50969c4f0a2257304e7e88016b0044a92b996b63bd23267f72518c51a79936e">UART_DATA_8_BITS</a> = 0x3, 
<br />
&#160;&#160;<b>UART_DATA_BITS_MAX</b> = 0x4
<br />
 }<tr class="memdesc:aab50969c4f0a2257304e7e88016b0044"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART word length constants.  <a href="tesst_8h.html#aab50969c4f0a2257304e7e88016b0044">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aab50969c4f0a2257304e7e88016b0044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da57a73bbdbf830b845d4116f8341d7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a6da57a73bbdbf830b845d4116f8341d7">uart_stop_bits_t</a> { <a class="el" href="tesst_8h.html#a6da57a73bbdbf830b845d4116f8341d7a44b3bfbe90aebe2b23227f5c011f41cc">UART_STOP_BITS_1</a> = 0x1, 
<a class="el" href="tesst_8h.html#a6da57a73bbdbf830b845d4116f8341d7a5e3880b6868c824f0a76663f8ee5270f">UART_STOP_BITS_1_5</a> = 0x2, 
<a class="el" href="tesst_8h.html#a6da57a73bbdbf830b845d4116f8341d7a00c73c92b3d624bc86cfa63636dd99b3">UART_STOP_BITS_2</a> = 0x3, 
<b>UART_STOP_BITS_MAX</b> = 0x4
 }<tr class="memdesc:a6da57a73bbdbf830b845d4116f8341d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART stop bits number.  <a href="tesst_8h.html#a6da57a73bbdbf830b845d4116f8341d7">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a6da57a73bbdbf830b845d4116f8341d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f28644638bd57536eb5260695e83de9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> { <a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9a58fd32e284dbcb8b75d4d7b73760827f">UART_NUM_0</a> = 0x0, 
<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9a7bbf3455b5ac5115b6609c6296188f0f">UART_NUM_1</a> = 0x1, 
<b>UART_NUM_MAX</b>
 }<tr class="memdesc:a7f28644638bd57536eb5260695e83de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART peripheral number.  <a href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a7f28644638bd57536eb5260695e83de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bcc37e31dd40c204b4ac6f6189e8878"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a6bcc37e31dd40c204b4ac6f6189e8878">uart_parity_t</a> { <a class="el" href="tesst_8h.html#a6bcc37e31dd40c204b4ac6f6189e8878aaacbb6cf4a984331ce0784edb10e1d65">UART_PARITY_DISABLE</a> = 0x0, 
<a class="el" href="tesst_8h.html#a6bcc37e31dd40c204b4ac6f6189e8878ad908a637b1dd23f93b149dd2d8bdfdb8">UART_PARITY_EVEN</a> = 0x2, 
<a class="el" href="tesst_8h.html#a6bcc37e31dd40c204b4ac6f6189e8878ad90cc425f5ba447773a44a75be6593e2">UART_PARITY_ODD</a> = 0x3
 }<tr class="memdesc:a6bcc37e31dd40c204b4ac6f6189e8878"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART parity constants.  <a href="tesst_8h.html#a6bcc37e31dd40c204b4ac6f6189e8878">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a6bcc37e31dd40c204b4ac6f6189e8878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4866947d21bd2902ba97ff2273028c9e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a4866947d21bd2902ba97ff2273028c9e">uart_hw_flowcontrol_t</a> { <br />
&#160;&#160;<a class="el" href="tesst_8h.html#a4866947d21bd2902ba97ff2273028c9eaf5fbb68dace1cef615b349cbceeb5334">UART_HW_FLOWCTRL_DISABLE</a> = 0x0, 
<a class="el" href="tesst_8h.html#a4866947d21bd2902ba97ff2273028c9ea5a3d78eb8ac164374c8f108e570cb664">UART_HW_FLOWCTRL_RTS</a> = 0x1, 
<a class="el" href="tesst_8h.html#a4866947d21bd2902ba97ff2273028c9eaa13ec62ff02b7471017864a39cf52460">UART_HW_FLOWCTRL_CTS</a> = 0x2, 
<a class="el" href="tesst_8h.html#a4866947d21bd2902ba97ff2273028c9ea25f457d713ea53655fa394e335f15e62">UART_HW_FLOWCTRL_CTS_RTS</a> = 0x3, 
<br />
&#160;&#160;<b>UART_HW_FLOWCTRL_MAX</b> = 0x4
<br />
 }<tr class="memdesc:a4866947d21bd2902ba97ff2273028c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART hardware flow control modes.  <a href="tesst_8h.html#a4866947d21bd2902ba97ff2273028c9e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a4866947d21bd2902ba97ff2273028c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33921674d20cc4e8c996134afc94caf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#aa33921674d20cc4e8c996134afc94caf">uart_event_type_t</a> { <br />
&#160;&#160;<a class="el" href="tesst_8h.html#aa33921674d20cc4e8c996134afc94cafab8cffca7dac643fb53ca35bd20214882">UART_DATA</a>, 
<a class="el" href="tesst_8h.html#aa33921674d20cc4e8c996134afc94cafa4986147e23cc46ab8c2aa7e151d09571">UART_BREAK</a>, 
<a class="el" href="tesst_8h.html#aa33921674d20cc4e8c996134afc94cafa12578023d68c7c43e33bac855ad394fd">UART_BUFFER_FULL</a>, 
<a class="el" href="tesst_8h.html#aa33921674d20cc4e8c996134afc94cafad4404c87268f285a8b5551efc4fa121e">UART_FIFO_OVF</a>, 
<br />
&#160;&#160;<a class="el" href="tesst_8h.html#aa33921674d20cc4e8c996134afc94cafa32a1926931bdd145a394fccbd75ec4f0">UART_FRAME_ERR</a>, 
<a class="el" href="tesst_8h.html#aa33921674d20cc4e8c996134afc94cafa93e1a6617858153f2c39c1ec54cbfade">UART_PARITY_ERR</a>, 
<a class="el" href="tesst_8h.html#aa33921674d20cc4e8c996134afc94cafa1c2eb56d729c73b734c7997d4ca5aabe">UART_DATA_BREAK</a>, 
<a class="el" href="tesst_8h.html#aa33921674d20cc4e8c996134afc94cafa8d13ac936522dd215489629e89c07b1e">UART_PATTERN_DET</a>, 
<br />
&#160;&#160;<a class="el" href="tesst_8h.html#aa33921674d20cc4e8c996134afc94cafa4aebcf28effb5c6f8a42abf2f957025b">UART_EVENT_MAX</a>
<br />
 }<tr class="memdesc:aa33921674d20cc4e8c996134afc94caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART event types used in the ring buffer.  <a href="tesst_8h.html#aa33921674d20cc4e8c996134afc94caf">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aa33921674d20cc4e8c996134afc94caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a381a64f7f548b370e081ff193a4210e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a381a64f7f548b370e081ff193a4210e7">uart_is_driver_installed</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num)</td></tr>
<tr class="memdesc:a381a64f7f548b370e081ff193a4210e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the driver is installed or not.  <a href="#a381a64f7f548b370e081ff193a4210e7">More...</a><br /></td></tr>
<tr class="separator:a381a64f7f548b370e081ff193a4210e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808676f2b0888e32d32845867dee2696"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a808676f2b0888e32d32845867dee2696">uart_set_word_length</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, <a class="el" href="tesst_8h.html#aab50969c4f0a2257304e7e88016b0044">uart_word_length_t</a> data_bit)</td></tr>
<tr class="memdesc:a808676f2b0888e32d32845867dee2696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART data bits.  <a href="#a808676f2b0888e32d32845867dee2696">More...</a><br /></td></tr>
<tr class="separator:a808676f2b0888e32d32845867dee2696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e265fcff2bccfb9767317acebffb5f"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a23e265fcff2bccfb9767317acebffb5f">uart_get_word_length</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, <a class="el" href="tesst_8h.html#aab50969c4f0a2257304e7e88016b0044">uart_word_length_t</a> *data_bit)</td></tr>
<tr class="memdesc:a23e265fcff2bccfb9767317acebffb5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get UART data bits.  <a href="#a23e265fcff2bccfb9767317acebffb5f">More...</a><br /></td></tr>
<tr class="separator:a23e265fcff2bccfb9767317acebffb5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557ff2a2cd3d3d83acc072df8af9e4bf"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a557ff2a2cd3d3d83acc072df8af9e4bf">uart_set_stop_bits</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, <a class="el" href="tesst_8h.html#a6da57a73bbdbf830b845d4116f8341d7">uart_stop_bits_t</a> stop_bits)</td></tr>
<tr class="memdesc:a557ff2a2cd3d3d83acc072df8af9e4bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART stop bits.  <a href="#a557ff2a2cd3d3d83acc072df8af9e4bf">More...</a><br /></td></tr>
<tr class="separator:a557ff2a2cd3d3d83acc072df8af9e4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc7f04203ccda3e93a3c0f77dbcfd09"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#abdc7f04203ccda3e93a3c0f77dbcfd09">uart_get_stop_bits</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, <a class="el" href="tesst_8h.html#a6da57a73bbdbf830b845d4116f8341d7">uart_stop_bits_t</a> *stop_bits)</td></tr>
<tr class="memdesc:abdc7f04203ccda3e93a3c0f77dbcfd09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get UART stop bits.  <a href="#abdc7f04203ccda3e93a3c0f77dbcfd09">More...</a><br /></td></tr>
<tr class="separator:abdc7f04203ccda3e93a3c0f77dbcfd09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b637bcc5b144866907fe2af67047b3b"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a8b637bcc5b144866907fe2af67047b3b">uart_set_parity</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, <a class="el" href="tesst_8h.html#a6bcc37e31dd40c204b4ac6f6189e8878">uart_parity_t</a> parity_mode)</td></tr>
<tr class="memdesc:a8b637bcc5b144866907fe2af67047b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART parity mode.  <a href="#a8b637bcc5b144866907fe2af67047b3b">More...</a><br /></td></tr>
<tr class="separator:a8b637bcc5b144866907fe2af67047b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcbfeedc6a77806fd0ba3fa7534ee073"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#abcbfeedc6a77806fd0ba3fa7534ee073">uart_get_parity</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, <a class="el" href="tesst_8h.html#a6bcc37e31dd40c204b4ac6f6189e8878">uart_parity_t</a> *parity_mode)</td></tr>
<tr class="memdesc:abcbfeedc6a77806fd0ba3fa7534ee073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get UART parity mode.  <a href="#abcbfeedc6a77806fd0ba3fa7534ee073">More...</a><br /></td></tr>
<tr class="separator:abcbfeedc6a77806fd0ba3fa7534ee073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77efdf5168e7269213a98298dacb5d58"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a77efdf5168e7269213a98298dacb5d58">uart_set_baudrate</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, uint32_t baudrate)</td></tr>
<tr class="memdesc:a77efdf5168e7269213a98298dacb5d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART baud rate.  <a href="#a77efdf5168e7269213a98298dacb5d58">More...</a><br /></td></tr>
<tr class="separator:a77efdf5168e7269213a98298dacb5d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409b45d7f0e70b3ef495538faeab11d2"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a409b45d7f0e70b3ef495538faeab11d2">uart_get_baudrate</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, uint32_t *baudrate)</td></tr>
<tr class="memdesc:a409b45d7f0e70b3ef495538faeab11d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get UART baud rate.  <a href="#a409b45d7f0e70b3ef495538faeab11d2">More...</a><br /></td></tr>
<tr class="separator:a409b45d7f0e70b3ef495538faeab11d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeaf7062ad7d6763f4713c67f7685151"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#adeaf7062ad7d6763f4713c67f7685151">uart_set_line_inverse</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, uint32_t inverse_mask)</td></tr>
<tr class="memdesc:adeaf7062ad7d6763f4713c67f7685151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART line inverse mode.  <a href="#adeaf7062ad7d6763f4713c67f7685151">More...</a><br /></td></tr>
<tr class="separator:adeaf7062ad7d6763f4713c67f7685151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4457ec08abdc9dbae7a5f4f1031002"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a3d4457ec08abdc9dbae7a5f4f1031002">uart_set_hw_flow_ctrl</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, <a class="el" href="tesst_8h.html#a4866947d21bd2902ba97ff2273028c9e">uart_hw_flowcontrol_t</a> flow_ctrl, uint8_t rx_thresh)</td></tr>
<tr class="memdesc:a3d4457ec08abdc9dbae7a5f4f1031002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set hardware flow control.  <a href="#a3d4457ec08abdc9dbae7a5f4f1031002">More...</a><br /></td></tr>
<tr class="separator:a3d4457ec08abdc9dbae7a5f4f1031002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3473b99b93b1671bc38c17e09ed72f3"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#aa3473b99b93b1671bc38c17e09ed72f3">uart_set_sw_flow_ctrl</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, bool enable, uint8_t rx_thresh_xon, uint8_t rx_thresh_xoff)</td></tr>
<tr class="memdesc:aa3473b99b93b1671bc38c17e09ed72f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set software flow control.  <a href="#aa3473b99b93b1671bc38c17e09ed72f3">More...</a><br /></td></tr>
<tr class="separator:aa3473b99b93b1671bc38c17e09ed72f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb10d50ebdb733917ba941226fb52164"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#abb10d50ebdb733917ba941226fb52164">uart_get_hw_flow_ctrl</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, <a class="el" href="tesst_8h.html#a4866947d21bd2902ba97ff2273028c9e">uart_hw_flowcontrol_t</a> *flow_ctrl)</td></tr>
<tr class="memdesc:abb10d50ebdb733917ba941226fb52164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get hardware flow control mode.  <a href="#abb10d50ebdb733917ba941226fb52164">More...</a><br /></td></tr>
<tr class="separator:abb10d50ebdb733917ba941226fb52164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1fb2f0c77a5711af1dad15013285ee"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#afc1fb2f0c77a5711af1dad15013285ee">uart_clear_intr_status</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, uint32_t clr_mask)</td></tr>
<tr class="memdesc:afc1fb2f0c77a5711af1dad15013285ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear UART interrupt status.  <a href="#afc1fb2f0c77a5711af1dad15013285ee">More...</a><br /></td></tr>
<tr class="separator:afc1fb2f0c77a5711af1dad15013285ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e5f3bf85282611dfdf91fbcf9ab5b0"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#ac1e5f3bf85282611dfdf91fbcf9ab5b0">uart_enable_intr_mask</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, uint32_t enable_mask)</td></tr>
<tr class="memdesc:ac1e5f3bf85282611dfdf91fbcf9ab5b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART interrupt enable.  <a href="#ac1e5f3bf85282611dfdf91fbcf9ab5b0">More...</a><br /></td></tr>
<tr class="separator:ac1e5f3bf85282611dfdf91fbcf9ab5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2529c04af335aa09b089cd092f9496a1"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a2529c04af335aa09b089cd092f9496a1">uart_disable_intr_mask</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, uint32_t disable_mask)</td></tr>
<tr class="memdesc:a2529c04af335aa09b089cd092f9496a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear UART interrupt enable bits.  <a href="#a2529c04af335aa09b089cd092f9496a1">More...</a><br /></td></tr>
<tr class="separator:a2529c04af335aa09b089cd092f9496a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf76305bb1e7ec4ffd1c71799bb2e24"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#aeaf76305bb1e7ec4ffd1c71799bb2e24">uart_enable_rx_intr</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num)</td></tr>
<tr class="memdesc:aeaf76305bb1e7ec4ffd1c71799bb2e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable UART RX interrupt (RX_FULL &amp; RX_TIMEOUT INTERRUPT)  <a href="#aeaf76305bb1e7ec4ffd1c71799bb2e24">More...</a><br /></td></tr>
<tr class="separator:aeaf76305bb1e7ec4ffd1c71799bb2e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff6c82a2fe5d3bd46a30f48972f282c"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#adff6c82a2fe5d3bd46a30f48972f282c">uart_disable_rx_intr</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num)</td></tr>
<tr class="memdesc:adff6c82a2fe5d3bd46a30f48972f282c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable UART RX interrupt (RX_FULL &amp; RX_TIMEOUT INTERRUPT)  <a href="#adff6c82a2fe5d3bd46a30f48972f282c">More...</a><br /></td></tr>
<tr class="separator:adff6c82a2fe5d3bd46a30f48972f282c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d5cc483b5b24d89b2610e04640dd00"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a17d5cc483b5b24d89b2610e04640dd00">uart_disable_tx_intr</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num)</td></tr>
<tr class="memdesc:a17d5cc483b5b24d89b2610e04640dd00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable UART TX interrupt (TX_FULL &amp; TX_TIMEOUT INTERRUPT)  <a href="#a17d5cc483b5b24d89b2610e04640dd00">More...</a><br /></td></tr>
<tr class="separator:a17d5cc483b5b24d89b2610e04640dd00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb256b93e7c57731a7745f08fdf07f8"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#afdb256b93e7c57731a7745f08fdf07f8">uart_enable_tx_intr</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, int enable, int thresh)</td></tr>
<tr class="memdesc:afdb256b93e7c57731a7745f08fdf07f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable UART TX interrupt (TX_FULL &amp; TX_TIMEOUT INTERRUPT)  <a href="#afdb256b93e7c57731a7745f08fdf07f8">More...</a><br /></td></tr>
<tr class="separator:afdb256b93e7c57731a7745f08fdf07f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2413646de281325acb5b771e48150f69"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a2413646de281325acb5b771e48150f69">uart_isr_register</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, void(*fn)(void *), void *arg, int intr_alloc_flags, uart_isr_handle_t *handle)</td></tr>
<tr class="memdesc:a2413646de281325acb5b771e48150f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register UART interrupt handler (ISR).  <a href="#a2413646de281325acb5b771e48150f69">More...</a><br /></td></tr>
<tr class="separator:a2413646de281325acb5b771e48150f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6394bf24366f7d850034e3949ee57b32"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a6394bf24366f7d850034e3949ee57b32">uart_isr_free</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num)</td></tr>
<tr class="memdesc:a6394bf24366f7d850034e3949ee57b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free UART interrupt handler registered by uart_isr_register. Must be called on the same core as uart_isr_register was called.  <a href="#a6394bf24366f7d850034e3949ee57b32">More...</a><br /></td></tr>
<tr class="separator:a6394bf24366f7d850034e3949ee57b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fae9b92aa2400b4098500fad67bf130"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a9fae9b92aa2400b4098500fad67bf130">uart_set_pin</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, int tx_io_num, int rx_io_num, int rts_io_num, int cts_io_num)</td></tr>
<tr class="memdesc:a9fae9b92aa2400b4098500fad67bf130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART pin number.  <a href="#a9fae9b92aa2400b4098500fad67bf130">More...</a><br /></td></tr>
<tr class="separator:a9fae9b92aa2400b4098500fad67bf130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6005ed5198bccb515f3a45332651fe3f"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a6005ed5198bccb515f3a45332651fe3f">uart_set_rts</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, int level)</td></tr>
<tr class="memdesc:a6005ed5198bccb515f3a45332651fe3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually set the UART RTS pin level.  <a href="#a6005ed5198bccb515f3a45332651fe3f">More...</a><br /></td></tr>
<tr class="separator:a6005ed5198bccb515f3a45332651fe3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03a824b0b24952fc20c26ec0927dc40"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#af03a824b0b24952fc20c26ec0927dc40">uart_set_dtr</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, int level)</td></tr>
<tr class="memdesc:af03a824b0b24952fc20c26ec0927dc40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually set the UART DTR pin level.  <a href="#af03a824b0b24952fc20c26ec0927dc40">More...</a><br /></td></tr>
<tr class="separator:af03a824b0b24952fc20c26ec0927dc40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698ddea081872eb46338cc23aaeac599"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a698ddea081872eb46338cc23aaeac599">uart_set_tx_idle_num</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, uint16_t idle_num)</td></tr>
<tr class="memdesc:a698ddea081872eb46338cc23aaeac599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART idle interval after tx FIFO is empty.  <a href="#a698ddea081872eb46338cc23aaeac599">More...</a><br /></td></tr>
<tr class="separator:a698ddea081872eb46338cc23aaeac599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26909ef7d30875c035d74febd31fc444"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a26909ef7d30875c035d74febd31fc444">uart_param_config</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, const <a class="el" href="structuart__config__t.html">uart_config_t</a> *uart_config)</td></tr>
<tr class="memdesc:a26909ef7d30875c035d74febd31fc444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART configuration parameters.  <a href="#a26909ef7d30875c035d74febd31fc444">More...</a><br /></td></tr>
<tr class="separator:a26909ef7d30875c035d74febd31fc444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4c7d4dc9d293e98505a903e99c200f"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a2a4c7d4dc9d293e98505a903e99c200f">uart_intr_config</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, const <a class="el" href="structuart__intr__config__t.html">uart_intr_config_t</a> *intr_conf)</td></tr>
<tr class="memdesc:a2a4c7d4dc9d293e98505a903e99c200f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure UART interrupts.  <a href="#a2a4c7d4dc9d293e98505a903e99c200f">More...</a><br /></td></tr>
<tr class="separator:a2a4c7d4dc9d293e98505a903e99c200f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af668e653f7b0af9dbf55cdb5be839ec9"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#af668e653f7b0af9dbf55cdb5be839ec9">uart_driver_install</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, int rx_buffer_size, int tx_buffer_size, int queue_size, QueueHandle_t *uart_queue, int intr_alloc_flags)</td></tr>
<tr class="memdesc:af668e653f7b0af9dbf55cdb5be839ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install UART driver.  <a href="#af668e653f7b0af9dbf55cdb5be839ec9">More...</a><br /></td></tr>
<tr class="separator:af668e653f7b0af9dbf55cdb5be839ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14d79ece50100374ef756b6eb4675d5"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#af14d79ece50100374ef756b6eb4675d5">uart_driver_delete</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num)</td></tr>
<tr class="memdesc:af14d79ece50100374ef756b6eb4675d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uninstall UART driver.  <a href="#af14d79ece50100374ef756b6eb4675d5">More...</a><br /></td></tr>
<tr class="separator:af14d79ece50100374ef756b6eb4675d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee69c880882e652759d03f2614d95af"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#adee69c880882e652759d03f2614d95af">uart_wait_tx_done</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, TickType_t ticks_to_wait)</td></tr>
<tr class="memdesc:adee69c880882e652759d03f2614d95af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until UART TX FIFO is empty.  <a href="#adee69c880882e652759d03f2614d95af">More...</a><br /></td></tr>
<tr class="separator:adee69c880882e652759d03f2614d95af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca552dc1f99b6ed8d74b81d835344eba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#aca552dc1f99b6ed8d74b81d835344eba">uart_tx_chars</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, const char *buffer, uint32_t len)</td></tr>
<tr class="memdesc:aca552dc1f99b6ed8d74b81d835344eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data to the UART port from a given buffer and length.  <a href="#aca552dc1f99b6ed8d74b81d835344eba">More...</a><br /></td></tr>
<tr class="separator:aca552dc1f99b6ed8d74b81d835344eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2411719e618a486919676f592559e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a4c2411719e618a486919676f592559e8">uart_write_bytes</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, const char *src, size_t size)</td></tr>
<tr class="memdesc:a4c2411719e618a486919676f592559e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data to the UART port from a given buffer and length,.  <a href="#a4c2411719e618a486919676f592559e8">More...</a><br /></td></tr>
<tr class="separator:a4c2411719e618a486919676f592559e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b44b6ad999b97a2e6b23e3a981c874"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a77b44b6ad999b97a2e6b23e3a981c874">uart_write_bytes_with_break</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, const char *src, size_t size, int brk_len)</td></tr>
<tr class="memdesc:a77b44b6ad999b97a2e6b23e3a981c874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data to the UART port from a given buffer and length,.  <a href="#a77b44b6ad999b97a2e6b23e3a981c874">More...</a><br /></td></tr>
<tr class="separator:a77b44b6ad999b97a2e6b23e3a981c874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada873c6deef1c1b23f76b3bc6e886339"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#ada873c6deef1c1b23f76b3bc6e886339">uart_read_bytes</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, uint8_t *buf, uint32_t length, TickType_t ticks_to_wait)</td></tr>
<tr class="memdesc:ada873c6deef1c1b23f76b3bc6e886339"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART read bytes from UART buffer.  <a href="#ada873c6deef1c1b23f76b3bc6e886339">More...</a><br /></td></tr>
<tr class="separator:ada873c6deef1c1b23f76b3bc6e886339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6df979239b59c1d04ec3ef3db99127"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a1d6df979239b59c1d04ec3ef3db99127">uart_flush</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num)</td></tr>
<tr class="memdesc:a1d6df979239b59c1d04ec3ef3db99127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias of uart_flush_input. UART ring buffer flush. This will discard all data in the UART RX buffer.  <a href="#a1d6df979239b59c1d04ec3ef3db99127">More...</a><br /></td></tr>
<tr class="separator:a1d6df979239b59c1d04ec3ef3db99127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068def261085c0aea676689328e5a255"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a068def261085c0aea676689328e5a255">uart_flush_input</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num)</td></tr>
<tr class="memdesc:a068def261085c0aea676689328e5a255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear input buffer, discard all the data is in the ring-buffer.  <a href="#a068def261085c0aea676689328e5a255">More...</a><br /></td></tr>
<tr class="separator:a068def261085c0aea676689328e5a255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f71f946b85f3029c6b21cb0ee320f9"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a40f71f946b85f3029c6b21cb0ee320f9">uart_get_buffered_data_len</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, size_t *size)</td></tr>
<tr class="memdesc:a40f71f946b85f3029c6b21cb0ee320f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART get RX ring buffer cached data length.  <a href="#a40f71f946b85f3029c6b21cb0ee320f9">More...</a><br /></td></tr>
<tr class="separator:a40f71f946b85f3029c6b21cb0ee320f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e37088bdce71c0137e52fd8b6786130"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a8e37088bdce71c0137e52fd8b6786130">uart_disable_pattern_det_intr</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num)</td></tr>
<tr class="memdesc:a8e37088bdce71c0137e52fd8b6786130"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART disable pattern detect function. Designed for applications like 'AT commands'. When the hardware detects a series of one same character, the interrupt will be triggered.  <a href="#a8e37088bdce71c0137e52fd8b6786130">More...</a><br /></td></tr>
<tr class="separator:a8e37088bdce71c0137e52fd8b6786130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fcb877367ecf9b17e8f8380e7ded826"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a7fcb877367ecf9b17e8f8380e7ded826">uart_enable_pattern_det_intr</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, char pattern_chr, uint8_t chr_num, int chr_tout, int post_idle, int pre_idle)</td></tr>
<tr class="memdesc:a7fcb877367ecf9b17e8f8380e7ded826"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART enable pattern detect function. Designed for applications like 'AT commands'. When the hardware detect a series of one same character, the interrupt will be triggered.  <a href="#a7fcb877367ecf9b17e8f8380e7ded826">More...</a><br /></td></tr>
<tr class="separator:a7fcb877367ecf9b17e8f8380e7ded826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884eb8de9121304cce469cfa9292f0be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a884eb8de9121304cce469cfa9292f0be">uart_pattern_pop_pos</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num)</td></tr>
<tr class="memdesc:a884eb8de9121304cce469cfa9292f0be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the nearest detected pattern position in buffer. The positions of the detected pattern are saved in a queue, this function will dequeue the first pattern position and move the pointer to next pattern position.  <a href="#a884eb8de9121304cce469cfa9292f0be">More...</a><br /></td></tr>
<tr class="separator:a884eb8de9121304cce469cfa9292f0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a190fdc0b4d7b0e5e865b0cfb38383069"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a190fdc0b4d7b0e5e865b0cfb38383069">uart_pattern_get_pos</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num)</td></tr>
<tr class="memdesc:a190fdc0b4d7b0e5e865b0cfb38383069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the nearest detected pattern position in buffer. The positions of the detected pattern are saved in a queue, This function do nothing to the queue.  <a href="#a190fdc0b4d7b0e5e865b0cfb38383069">More...</a><br /></td></tr>
<tr class="separator:a190fdc0b4d7b0e5e865b0cfb38383069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e61a66fc42555cadd072adb907dd882"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a0e61a66fc42555cadd072adb907dd882">uart_pattern_queue_reset</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, int queue_length)</td></tr>
<tr class="memdesc:a0e61a66fc42555cadd072adb907dd882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new memory with the given length to save record the detected pattern position in rx buffer.  <a href="#a0e61a66fc42555cadd072adb907dd882">More...</a><br /></td></tr>
<tr class="separator:a0e61a66fc42555cadd072adb907dd882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950b10bb3fd5226fba28b633e92b4a53"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a950b10bb3fd5226fba28b633e92b4a53">uart_set_mode</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, <a class="el" href="tesst_8h.html#a93f7c73d772490ab4d22bda8fd0aa5a6">uart_mode_t</a> mode)</td></tr>
<tr class="memdesc:a950b10bb3fd5226fba28b633e92b4a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART set communication mode.  <a href="#a950b10bb3fd5226fba28b633e92b4a53">More...</a><br /></td></tr>
<tr class="separator:a950b10bb3fd5226fba28b633e92b4a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005d64fa971ebf3005e60f2adbf2fe0c"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a005d64fa971ebf3005e60f2adbf2fe0c">uart_set_rx_timeout</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, const uint8_t tout_thresh)</td></tr>
<tr class="memdesc:a005d64fa971ebf3005e60f2adbf2fe0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART set threshold timeout for TOUT feature.  <a href="#a005d64fa971ebf3005e60f2adbf2fe0c">More...</a><br /></td></tr>
<tr class="separator:a005d64fa971ebf3005e60f2adbf2fe0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010dea3538b131eb120886e92896de5d"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a010dea3538b131eb120886e92896de5d">uart_get_collision_flag</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, bool *collision_flag)</td></tr>
<tr class="memdesc:a010dea3538b131eb120886e92896de5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns collision detection flag for RS485 mode Function returns the collision detection flag into variable pointed by collision_flag. *collision_flag = true, if collision detected else it is equal to false. This function should be executed when actual transmission is completed (after <a class="el" href="tesst_8h.html#a4c2411719e618a486919676f592559e8" title="Send data to the UART port from a given buffer and length,. ">uart_write_bytes()</a>).  <a href="#a010dea3538b131eb120886e92896de5d">More...</a><br /></td></tr>
<tr class="separator:a010dea3538b131eb120886e92896de5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236f5ce8e193ce043cf6401201606f95"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a236f5ce8e193ce043cf6401201606f95">uart_set_wakeup_threshold</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, int wakeup_threshold)</td></tr>
<tr class="memdesc:a236f5ce8e193ce043cf6401201606f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of RX pin signal edges for light sleep wakeup.  <a href="#a236f5ce8e193ce043cf6401201606f95">More...</a><br /></td></tr>
<tr class="separator:a236f5ce8e193ce043cf6401201606f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e939ff165ec4b92cb31fc31b0026d0"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesst_8h.html#a12e939ff165ec4b92cb31fc31b0026d0">uart_get_wakeup_threshold</a> (<a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a> uart_num, int *out_wakeup_threshold)</td></tr>
<tr class="memdesc:a12e939ff165ec4b92cb31fc31b0026d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of RX pin signal edges for light sleep wakeup.  <a href="#a12e939ff165ec4b92cb31fc31b0026d0">More...</a><br /></td></tr>
<tr class="separator:a12e939ff165ec4b92cb31fc31b0026d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a653fc44b41db6efb3884c15ce8d6c30e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a653fc44b41db6efb3884c15ce8d6c30e">&#9670;&nbsp;</a></span>UART_FIFO_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_FIFO_LEN&#160;&#160;&#160;(128)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Length of the hardware FIFO buffers </p>

</div>
</div>
<a id="a236e4265357229fa5f9b586cc744866d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a236e4265357229fa5f9b586cc744866d">&#9670;&nbsp;</a></span>UART_INTR_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_INTR_MASK&#160;&#160;&#160;0x1ff</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mask of all UART interrupts </p>

</div>
</div>
<a id="a7652c930ed7eb1841c38419905e5eafd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7652c930ed7eb1841c38419905e5eafd">&#9670;&nbsp;</a></span>UART_LINE_INV_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_LINE_INV_MASK&#160;&#160;&#160;(0x3f &lt;&lt; 19)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TBD </p>

</div>
</div>
<a id="ab5636b7aad11849ee4c6f7c481dc07f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5636b7aad11849ee4c6f7c481dc07f6">&#9670;&nbsp;</a></span>UART_BITRATE_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_BITRATE_MAX&#160;&#160;&#160;5000000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Max bit rate supported by UART </p>

</div>
</div>
<a id="ab33b16f9bc23412d5d31f76d134a36db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab33b16f9bc23412d5d31f76d134a36db">&#9670;&nbsp;</a></span>UART_PIN_NO_CHANGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_PIN_NO_CHANGE&#160;&#160;&#160;(-1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constant for uart_set_pin function which indicates that UART pin \ should not be changed </p>

</div>
</div>
<a id="a683885aa03c7b605604d897e27cb5355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a683885aa03c7b605604d897e27cb5355">&#9670;&nbsp;</a></span>UART_INVERSE_DISABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_INVERSE_DISABLE&#160;&#160;&#160;(0x0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable UART signal inverse </p>

</div>
</div>
<a id="a12becc6acce13974ed835c4e67bbfa6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12becc6acce13974ed835c4e67bbfa6e">&#9670;&nbsp;</a></span>UART_INVERSE_RXD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_INVERSE_RXD&#160;&#160;&#160;(UART_RXD_INV_M)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART RXD input inverse </p>

</div>
</div>
<a id="a890cb40955ca53d14b6d92fca06ae9c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a890cb40955ca53d14b6d92fca06ae9c4">&#9670;&nbsp;</a></span>UART_INVERSE_CTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_INVERSE_CTS&#160;&#160;&#160;(UART_CTS_INV_M)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART CTS input inverse </p>

</div>
</div>
<a id="acda3c509c62bcca3bf7aae18218fb524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda3c509c62bcca3bf7aae18218fb524">&#9670;&nbsp;</a></span>UART_INVERSE_TXD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_INVERSE_TXD&#160;&#160;&#160;(UART_TXD_INV_M)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART TXD output inverse </p>

</div>
</div>
<a id="a930be76712b1217fba81c9cd541d532a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a930be76712b1217fba81c9cd541d532a">&#9670;&nbsp;</a></span>UART_INVERSE_RTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_INVERSE_RTS&#160;&#160;&#160;(UART_RTS_INV_M)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART RTS output inverse </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a93f7c73d772490ab4d22bda8fd0aa5a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f7c73d772490ab4d22bda8fd0aa5a6">&#9670;&nbsp;</a></span>uart_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="tesst_8h.html#a93f7c73d772490ab4d22bda8fd0aa5a6">uart_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART mode selection. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a93f7c73d772490ab4d22bda8fd0aa5a6a068436d1319f7158782d371df48a7651"></a>UART_MODE_UART&#160;</td><td class="fielddoc"><p>mode: regular UART mode </p>
</td></tr>
<tr><td class="fieldname"><a id="a93f7c73d772490ab4d22bda8fd0aa5a6a40e580a730e4271d4731437a0db660e5"></a>UART_MODE_RS485_HALF_DUPLEX&#160;</td><td class="fielddoc"><p>mode: half duplex RS485 UART mode control by RTS pin </p>
</td></tr>
<tr><td class="fieldname"><a id="a93f7c73d772490ab4d22bda8fd0aa5a6adc56553dfc0f8e278433c0f2fcf45ecc"></a>UART_MODE_IRDA&#160;</td><td class="fielddoc"><p>mode: IRDA UART mode </p>
</td></tr>
<tr><td class="fieldname"><a id="a93f7c73d772490ab4d22bda8fd0aa5a6a59417d152f9453f44081584bc16feb88"></a>UART_MODE_RS485_COLLISION_DETECT&#160;</td><td class="fielddoc"><p>mode: RS485 collision detection UART mode (used for test purposes) </p>
</td></tr>
<tr><td class="fieldname"><a id="a93f7c73d772490ab4d22bda8fd0aa5a6aac2905a4d8c52542451b87d4f7986fce"></a>UART_MODE_RS485_APP_CTRL&#160;</td><td class="fielddoc"><p>mode: application control RS485 UART mode (used for test purposes) </p>
</td></tr>
</table>

</div>
</div>
<a id="aab50969c4f0a2257304e7e88016b0044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab50969c4f0a2257304e7e88016b0044">&#9670;&nbsp;</a></span>uart_word_length_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="tesst_8h.html#aab50969c4f0a2257304e7e88016b0044">uart_word_length_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART word length constants. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aab50969c4f0a2257304e7e88016b0044a45437f3ff3941ae72e531dfb755456f4"></a>UART_DATA_5_BITS&#160;</td><td class="fielddoc"><p>word length: 5bits </p>
</td></tr>
<tr><td class="fieldname"><a id="aab50969c4f0a2257304e7e88016b0044a2f062e3e06c3560077fe86fef6b8d9cb"></a>UART_DATA_6_BITS&#160;</td><td class="fielddoc"><p>word length: 6bits </p>
</td></tr>
<tr><td class="fieldname"><a id="aab50969c4f0a2257304e7e88016b0044aa5bd9a1dad740644b4c60fe0a8f9addd"></a>UART_DATA_7_BITS&#160;</td><td class="fielddoc"><p>word length: 7bits </p>
</td></tr>
<tr><td class="fieldname"><a id="aab50969c4f0a2257304e7e88016b0044a92b996b63bd23267f72518c51a79936e"></a>UART_DATA_8_BITS&#160;</td><td class="fielddoc"><p>word length: 8bits </p>
</td></tr>
</table>

</div>
</div>
<a id="a6da57a73bbdbf830b845d4116f8341d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da57a73bbdbf830b845d4116f8341d7">&#9670;&nbsp;</a></span>uart_stop_bits_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="tesst_8h.html#a6da57a73bbdbf830b845d4116f8341d7">uart_stop_bits_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART stop bits number. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6da57a73bbdbf830b845d4116f8341d7a44b3bfbe90aebe2b23227f5c011f41cc"></a>UART_STOP_BITS_1&#160;</td><td class="fielddoc"><p>stop bit: 1bit </p>
</td></tr>
<tr><td class="fieldname"><a id="a6da57a73bbdbf830b845d4116f8341d7a5e3880b6868c824f0a76663f8ee5270f"></a>UART_STOP_BITS_1_5&#160;</td><td class="fielddoc"><p>stop bit: 1.5bits </p>
</td></tr>
<tr><td class="fieldname"><a id="a6da57a73bbdbf830b845d4116f8341d7a00c73c92b3d624bc86cfa63636dd99b3"></a>UART_STOP_BITS_2&#160;</td><td class="fielddoc"><p>stop bit: 2bits </p>
</td></tr>
</table>

</div>
</div>
<a id="a7f28644638bd57536eb5260695e83de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f28644638bd57536eb5260695e83de9">&#9670;&nbsp;</a></span>uart_port_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART peripheral number. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7f28644638bd57536eb5260695e83de9a58fd32e284dbcb8b75d4d7b73760827f"></a>UART_NUM_0&#160;</td><td class="fielddoc"><p>UART base address 0x3ff40000 </p>
</td></tr>
<tr><td class="fieldname"><a id="a7f28644638bd57536eb5260695e83de9a7bbf3455b5ac5115b6609c6296188f0f"></a>UART_NUM_1&#160;</td><td class="fielddoc"><p>UART base address 0x3ff50000 </p>
</td></tr>
</table>

</div>
</div>
<a id="a6bcc37e31dd40c204b4ac6f6189e8878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bcc37e31dd40c204b4ac6f6189e8878">&#9670;&nbsp;</a></span>uart_parity_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="tesst_8h.html#a6bcc37e31dd40c204b4ac6f6189e8878">uart_parity_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART parity constants. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6bcc37e31dd40c204b4ac6f6189e8878aaacbb6cf4a984331ce0784edb10e1d65"></a>UART_PARITY_DISABLE&#160;</td><td class="fielddoc"><p>Disable UART parity </p>
</td></tr>
<tr><td class="fieldname"><a id="a6bcc37e31dd40c204b4ac6f6189e8878ad908a637b1dd23f93b149dd2d8bdfdb8"></a>UART_PARITY_EVEN&#160;</td><td class="fielddoc"><p>Enable UART even parity </p>
</td></tr>
<tr><td class="fieldname"><a id="a6bcc37e31dd40c204b4ac6f6189e8878ad90cc425f5ba447773a44a75be6593e2"></a>UART_PARITY_ODD&#160;</td><td class="fielddoc"><p>Enable UART odd parity </p>
</td></tr>
</table>

</div>
</div>
<a id="a4866947d21bd2902ba97ff2273028c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4866947d21bd2902ba97ff2273028c9e">&#9670;&nbsp;</a></span>uart_hw_flowcontrol_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="tesst_8h.html#a4866947d21bd2902ba97ff2273028c9e">uart_hw_flowcontrol_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART hardware flow control modes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4866947d21bd2902ba97ff2273028c9eaf5fbb68dace1cef615b349cbceeb5334"></a>UART_HW_FLOWCTRL_DISABLE&#160;</td><td class="fielddoc"><p>disable hardware flow control </p>
</td></tr>
<tr><td class="fieldname"><a id="a4866947d21bd2902ba97ff2273028c9ea5a3d78eb8ac164374c8f108e570cb664"></a>UART_HW_FLOWCTRL_RTS&#160;</td><td class="fielddoc"><p>enable RX hardware flow control (rts) </p>
</td></tr>
<tr><td class="fieldname"><a id="a4866947d21bd2902ba97ff2273028c9eaa13ec62ff02b7471017864a39cf52460"></a>UART_HW_FLOWCTRL_CTS&#160;</td><td class="fielddoc"><p>enable TX hardware flow control (cts) </p>
</td></tr>
<tr><td class="fieldname"><a id="a4866947d21bd2902ba97ff2273028c9ea25f457d713ea53655fa394e335f15e62"></a>UART_HW_FLOWCTRL_CTS_RTS&#160;</td><td class="fielddoc"><p>enable hardware flow control </p>
</td></tr>
</table>

</div>
</div>
<a id="aa33921674d20cc4e8c996134afc94caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa33921674d20cc4e8c996134afc94caf">&#9670;&nbsp;</a></span>uart_event_type_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="tesst_8h.html#aa33921674d20cc4e8c996134afc94caf">uart_event_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART event types used in the ring buffer. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa33921674d20cc4e8c996134afc94cafab8cffca7dac643fb53ca35bd20214882"></a>UART_DATA&#160;</td><td class="fielddoc"><p>UART data event </p>
</td></tr>
<tr><td class="fieldname"><a id="aa33921674d20cc4e8c996134afc94cafa4986147e23cc46ab8c2aa7e151d09571"></a>UART_BREAK&#160;</td><td class="fielddoc"><p>UART break event </p>
</td></tr>
<tr><td class="fieldname"><a id="aa33921674d20cc4e8c996134afc94cafa12578023d68c7c43e33bac855ad394fd"></a>UART_BUFFER_FULL&#160;</td><td class="fielddoc"><p>UART RX buffer full event </p>
</td></tr>
<tr><td class="fieldname"><a id="aa33921674d20cc4e8c996134afc94cafad4404c87268f285a8b5551efc4fa121e"></a>UART_FIFO_OVF&#160;</td><td class="fielddoc"><p>UART FIFO overflow event </p>
</td></tr>
<tr><td class="fieldname"><a id="aa33921674d20cc4e8c996134afc94cafa32a1926931bdd145a394fccbd75ec4f0"></a>UART_FRAME_ERR&#160;</td><td class="fielddoc"><p>UART RX frame error event </p>
</td></tr>
<tr><td class="fieldname"><a id="aa33921674d20cc4e8c996134afc94cafa93e1a6617858153f2c39c1ec54cbfade"></a>UART_PARITY_ERR&#160;</td><td class="fielddoc"><p>UART RX parity event </p>
</td></tr>
<tr><td class="fieldname"><a id="aa33921674d20cc4e8c996134afc94cafa1c2eb56d729c73b734c7997d4ca5aabe"></a>UART_DATA_BREAK&#160;</td><td class="fielddoc"><p>UART TX data and break event </p>
</td></tr>
<tr><td class="fieldname"><a id="aa33921674d20cc4e8c996134afc94cafa8d13ac936522dd215489629e89c07b1e"></a>UART_PATTERN_DET&#160;</td><td class="fielddoc"><p>UART pattern detected </p>
</td></tr>
<tr><td class="fieldname"><a id="aa33921674d20cc4e8c996134afc94cafa4aebcf28effb5c6f8a42abf2f957025b"></a>UART_EVENT_MAX&#160;</td><td class="fielddoc"><p>UART event max index </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a381a64f7f548b370e081ff193a4210e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381a64f7f548b370e081ff193a4210e7">&#9670;&nbsp;</a></span>uart_is_driver_installed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool uart_is_driver_installed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the driver is installed or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART port number, the max port number is (UART_NUM_MAX -1).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>true driver is installed</li>
<li>false driver is not installed </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a808676f2b0888e32d32845867dee2696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808676f2b0888e32d32845867dee2696">&#9670;&nbsp;</a></span>uart_set_word_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_set_word_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#aab50969c4f0a2257304e7e88016b0044">uart_word_length_t</a>&#160;</td>
          <td class="paramname"><em>data_bit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set UART data bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">data_bit</td><td>UART data bits</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a23e265fcff2bccfb9767317acebffb5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e265fcff2bccfb9767317acebffb5f">&#9670;&nbsp;</a></span>uart_get_word_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_get_word_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#aab50969c4f0a2257304e7e88016b0044">uart_word_length_t</a> *&#160;</td>
          <td class="paramname"><em>data_bit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get UART data bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">data_bit</td><td>Pointer to accept value of UART data bits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_FAIL Parameter error</li>
<li>ESP_OK Success, result will be put in (*data_bit) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a557ff2a2cd3d3d83acc072df8af9e4bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a557ff2a2cd3d3d83acc072df8af9e4bf">&#9670;&nbsp;</a></span>uart_set_stop_bits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_set_stop_bits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a6da57a73bbdbf830b845d4116f8341d7">uart_stop_bits_t</a>&#160;</td>
          <td class="paramname"><em>stop_bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set UART stop bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">stop_bits</td><td>UART stop bits</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Fail </li>
</ul>
</dd></dl>

</div>
</div>
<a id="abdc7f04203ccda3e93a3c0f77dbcfd09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc7f04203ccda3e93a3c0f77dbcfd09">&#9670;&nbsp;</a></span>uart_get_stop_bits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_get_stop_bits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a6da57a73bbdbf830b845d4116f8341d7">uart_stop_bits_t</a> *&#160;</td>
          <td class="paramname"><em>stop_bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get UART stop bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">stop_bits</td><td>Pointer to accept value of UART stop bits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_FAIL Parameter error</li>
<li>ESP_OK Success, result will be put in (*stop_bit) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a8b637bcc5b144866907fe2af67047b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b637bcc5b144866907fe2af67047b3b">&#9670;&nbsp;</a></span>uart_set_parity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_set_parity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a6bcc37e31dd40c204b4ac6f6189e8878">uart_parity_t</a>&#160;</td>
          <td class="paramname"><em>parity_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set UART parity mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">parity_mode</td><td>the enum of uart parity configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_FAIL Parameter error</li>
<li>ESP_OK Success </li>
</ul>
</dd></dl>

</div>
</div>
<a id="abcbfeedc6a77806fd0ba3fa7534ee073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcbfeedc6a77806fd0ba3fa7534ee073">&#9670;&nbsp;</a></span>uart_get_parity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_get_parity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a6bcc37e31dd40c204b4ac6f6189e8878">uart_parity_t</a> *&#160;</td>
          <td class="paramname"><em>parity_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get UART parity mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">parity_mode</td><td>Pointer to accept value of UART parity mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_FAIL Parameter error</li>
<li>ESP_OK Success, result will be put in (*parity_mode) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a77efdf5168e7269213a98298dacb5d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77efdf5168e7269213a98298dacb5d58">&#9670;&nbsp;</a></span>uart_set_baudrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_set_baudrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baudrate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set UART baud rate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">baudrate</td><td>UART baud rate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_FAIL Parameter error</li>
<li>ESP_OK Success </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a409b45d7f0e70b3ef495538faeab11d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409b45d7f0e70b3ef495538faeab11d2">&#9670;&nbsp;</a></span>uart_get_baudrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_get_baudrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>baudrate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get UART baud rate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">baudrate</td><td>Pointer to accept value of UART baud rate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_FAIL Parameter error</li>
<li>ESP_OK Success, result will be put in (*baudrate) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="adeaf7062ad7d6763f4713c67f7685151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeaf7062ad7d6763f4713c67f7685151">&#9670;&nbsp;</a></span>uart_set_line_inverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_set_line_inverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>inverse_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set UART line inverse mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">inverse_mask</td><td>Choose the wires that need to be inverted. Inverse_mask should be chosen from UART_INVERSE_RXD / UART_INVERSE_TXD / UART_INVERSE_RTS / UART_INVERSE_CTS, combined with OR operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a3d4457ec08abdc9dbae7a5f4f1031002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4457ec08abdc9dbae7a5f4f1031002">&#9670;&nbsp;</a></span>uart_set_hw_flow_ctrl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_set_hw_flow_ctrl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a4866947d21bd2902ba97ff2273028c9e">uart_hw_flowcontrol_t</a>&#160;</td>
          <td class="paramname"><em>flow_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rx_thresh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set hardware flow control. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">flow_ctrl</td><td>Hardware flow control mode </td></tr>
    <tr><td class="paramname">rx_thresh</td><td>Threshold of Hardware RX flow control (0 ~ UART_FIFO_LEN). Only when UART_HW_FLOWCTRL_RTS is set, will the rx_thresh value be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa3473b99b93b1671bc38c17e09ed72f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3473b99b93b1671bc38c17e09ed72f3">&#9670;&nbsp;</a></span>uart_set_sw_flow_ctrl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_set_sw_flow_ctrl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rx_thresh_xon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rx_thresh_xoff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set software flow control. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">enable</td><td>switch on or off </td></tr>
    <tr><td class="paramname">rx_thresh_xon</td><td>low water mark </td></tr>
    <tr><td class="paramname">rx_thresh_xoff</td><td>high water mark</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="abb10d50ebdb733917ba941226fb52164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb10d50ebdb733917ba941226fb52164">&#9670;&nbsp;</a></span>uart_get_hw_flow_ctrl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_get_hw_flow_ctrl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a4866947d21bd2902ba97ff2273028c9e">uart_hw_flowcontrol_t</a> *&#160;</td>
          <td class="paramname"><em>flow_ctrl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get hardware flow control mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">flow_ctrl</td><td>Option for different flow control mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_FAIL Parameter error</li>
<li>ESP_OK Success, result will be put in (*flow_ctrl) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="afc1fb2f0c77a5711af1dad15013285ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1fb2f0c77a5711af1dad15013285ee">&#9670;&nbsp;</a></span>uart_clear_intr_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_clear_intr_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clr_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear UART interrupt status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">clr_mask</td><td>Bit mask of the interrupt status to be cleared. The bit mask should be composed from the fields of register UART_INT_CLR_REG.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac1e5f3bf85282611dfdf91fbcf9ab5b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e5f3bf85282611dfdf91fbcf9ab5b0">&#9670;&nbsp;</a></span>uart_enable_intr_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_enable_intr_mask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enable_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set UART interrupt enable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">enable_mask</td><td>Bit mask of the enable bits. The bit mask should be composed from the fields of register UART_INT_ENA_REG.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2529c04af335aa09b089cd092f9496a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2529c04af335aa09b089cd092f9496a1">&#9670;&nbsp;</a></span>uart_disable_intr_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_disable_intr_mask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>disable_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear UART interrupt enable bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">disable_mask</td><td>Bit mask of the disable bits. The bit mask should be composed from the fields of register UART_INT_ENA_REG.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aeaf76305bb1e7ec4ffd1c71799bb2e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf76305bb1e7ec4ffd1c71799bb2e24">&#9670;&nbsp;</a></span>uart_enable_rx_intr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_enable_rx_intr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable UART RX interrupt (RX_FULL &amp; RX_TIMEOUT INTERRUPT) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="adff6c82a2fe5d3bd46a30f48972f282c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adff6c82a2fe5d3bd46a30f48972f282c">&#9670;&nbsp;</a></span>uart_disable_rx_intr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_disable_rx_intr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable UART RX interrupt (RX_FULL &amp; RX_TIMEOUT INTERRUPT) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a17d5cc483b5b24d89b2610e04640dd00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d5cc483b5b24d89b2610e04640dd00">&#9670;&nbsp;</a></span>uart_disable_tx_intr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_disable_tx_intr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable UART TX interrupt (TX_FULL &amp; TX_TIMEOUT INTERRUPT) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="afdb256b93e7c57731a7745f08fdf07f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb256b93e7c57731a7745f08fdf07f8">&#9670;&nbsp;</a></span>uart_enable_tx_intr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_enable_tx_intr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thresh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable UART TX interrupt (TX_FULL &amp; TX_TIMEOUT INTERRUPT) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">enable</td><td>1: enable; 0: disable </td></tr>
    <tr><td class="paramname">thresh</td><td>Threshold of TX interrupt, 0 ~ UART_FIFO_LEN</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2413646de281325acb5b771e48150f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2413646de281325acb5b771e48150f69">&#9670;&nbsp;</a></span>uart_isr_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_isr_register </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>intr_alloc_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uart_isr_handle_t *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register UART interrupt handler (ISR). </p>
<dl class="section note"><dt>Note</dt><dd>UART ISR handler will be attached to the same CPU core that this function is running on.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">fn</td><td>Interrupt handler function. </td></tr>
    <tr><td class="paramname">arg</td><td>parameter for handler function </td></tr>
    <tr><td class="paramname">intr_alloc_flags</td><td>Flags used to allocate the interrupt. One or multiple (ORred) ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info. </td></tr>
    <tr><td class="paramname">handle</td><td>Pointer to return handle. If non-NULL, a handle for the interrupt will be returned here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6394bf24366f7d850034e3949ee57b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6394bf24366f7d850034e3949ee57b32">&#9670;&nbsp;</a></span>uart_isr_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_isr_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free UART interrupt handler registered by uart_isr_register. Must be called on the same core as uart_isr_register was called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a9fae9b92aa2400b4098500fad67bf130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fae9b92aa2400b4098500fad67bf130">&#9670;&nbsp;</a></span>uart_set_pin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_set_pin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tx_io_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rx_io_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rts_io_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cts_io_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set UART pin number. </p>
<dl class="section note"><dt>Note</dt><dd>Internal signal can be output to multiple GPIO pads. Only one GPIO pad can connect with input signal.</dd>
<dd>
Instead of GPIO number a macro 'UART_PIN_NO_CHANGE' may be provided to keep the currently allocated pin.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">tx_io_num</td><td>UART TX pin GPIO number. </td></tr>
    <tr><td class="paramname">rx_io_num</td><td>UART RX pin GPIO number. </td></tr>
    <tr><td class="paramname">rts_io_num</td><td>UART RTS pin GPIO number. </td></tr>
    <tr><td class="paramname">cts_io_num</td><td>UART CTS pin GPIO number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6005ed5198bccb515f3a45332651fe3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6005ed5198bccb515f3a45332651fe3f">&#9670;&nbsp;</a></span>uart_set_rts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_set_rts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manually set the UART RTS pin level. </p>
<dl class="section note"><dt>Note</dt><dd>UART must be configured with hardware flow control disabled.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">level</td><td>1: RTS output low (active); 0: RTS output high (block)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af03a824b0b24952fc20c26ec0927dc40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af03a824b0b24952fc20c26ec0927dc40">&#9670;&nbsp;</a></span>uart_set_dtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_set_dtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manually set the UART DTR pin level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">level</td><td>1: DTR output low; 0: DTR output high</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a698ddea081872eb46338cc23aaeac599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a698ddea081872eb46338cc23aaeac599">&#9670;&nbsp;</a></span>uart_set_tx_idle_num()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_set_tx_idle_num </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>idle_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set UART idle interval after tx FIFO is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">idle_num</td><td>idle interval after tx FIFO is empty(unit: the time it takes to send one bit under current baudrate)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a26909ef7d30875c035d74febd31fc444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26909ef7d30875c035d74febd31fc444">&#9670;&nbsp;</a></span>uart_param_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_param_config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structuart__config__t.html">uart_config_t</a> *&#160;</td>
          <td class="paramname"><em>uart_config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set UART configuration parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">uart_config</td><td>UART parameter settings</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2a4c7d4dc9d293e98505a903e99c200f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a4c7d4dc9d293e98505a903e99c200f">&#9670;&nbsp;</a></span>uart_intr_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_intr_config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structuart__intr__config__t.html">uart_intr_config_t</a> *&#160;</td>
          <td class="paramname"><em>intr_conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure UART interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">intr_conf</td><td>UART interrupt settings</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af668e653f7b0af9dbf55cdb5be839ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af668e653f7b0af9dbf55cdb5be839ec9">&#9670;&nbsp;</a></span>uart_driver_install()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_driver_install </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rx_buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tx_buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queue_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QueueHandle_t *&#160;</td>
          <td class="paramname"><em>uart_queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>intr_alloc_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install UART driver. </p>
<p>UART ISR handler will be attached to the same CPU core that this function is running on.</p>
<dl class="section note"><dt>Note</dt><dd>Rx_buffer_size should be greater than UART_FIFO_LEN. Tx_buffer_size should be either zero or greater than UART_FIFO_LEN.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">rx_buffer_size</td><td>UART RX ring buffer size. </td></tr>
    <tr><td class="paramname">tx_buffer_size</td><td>UART TX ring buffer size. If set to zero, driver will not use TX buffer, TX function will block task until all data have been sent out. </td></tr>
    <tr><td class="paramname">queue_size</td><td>UART event queue size/depth. </td></tr>
    <tr><td class="paramname">uart_queue</td><td>UART event queue handle (out param). On success, a new queue handle is written here to provide access to UART events. If set to NULL, driver will not use an event queue. </td></tr>
    <tr><td class="paramname">intr_alloc_flags</td><td>Flags used to allocate the interrupt. One or multiple (ORred) ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info. Do not set ESP_INTR_FLAG_IRAM here (the driver's ISR handler is not located in IRAM)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af14d79ece50100374ef756b6eb4675d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af14d79ece50100374ef756b6eb4675d5">&#9670;&nbsp;</a></span>uart_driver_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_driver_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uninstall UART driver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="adee69c880882e652759d03f2614d95af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adee69c880882e652759d03f2614d95af">&#9670;&nbsp;</a></span>uart_wait_tx_done()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_wait_tx_done </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TickType_t&#160;</td>
          <td class="paramname"><em>ticks_to_wait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until UART TX FIFO is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">ticks_to_wait</td><td>Timeout, count in RTOS ticks</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error</li>
<li>ESP_ERR_TIMEOUT Timeout </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aca552dc1f99b6ed8d74b81d835344eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca552dc1f99b6ed8d74b81d835344eba">&#9670;&nbsp;</a></span>uart_tx_chars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int uart_tx_chars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data to the UART port from a given buffer and length. </p>
<p>This function will not wait for enough space in TX FIFO. It will just fill the available TX FIFO and return when the FIFO is full. </p><dl class="section note"><dt>Note</dt><dd>This function should only be used when UART TX buffer is not enabled.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">buffer</td><td>data buffer address </td></tr>
    <tr><td class="paramname">len</td><td>data length to send</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(-1) Parameter error</li>
<li>OTHERS (&gt;=0) The number of bytes pushed to the TX FIFO </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a4c2411719e618a486919676f592559e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2411719e618a486919676f592559e8">&#9670;&nbsp;</a></span>uart_write_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int uart_write_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data to the UART port from a given buffer and length,. </p>
<p>If the UART driver's parameter 'tx_buffer_size' is set to zero: This function will not return until all the data have been sent out, or at least pushed into TX FIFO.</p>
<p>Otherwise, if the 'tx_buffer_size' &gt; 0, this function will return after copying all the data to tx ring buffer, UART ISR will then move data from the ring buffer to TX FIFO gradually.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">src</td><td>data buffer address </td></tr>
    <tr><td class="paramname">size</td><td>data length to send</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(-1) Parameter error</li>
<li>OTHERS (&gt;=0) The number of bytes pushed to the TX FIFO </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a77b44b6ad999b97a2e6b23e3a981c874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b44b6ad999b97a2e6b23e3a981c874">&#9670;&nbsp;</a></span>uart_write_bytes_with_break()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int uart_write_bytes_with_break </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>brk_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data to the UART port from a given buffer and length,. </p>
<p>If the UART driver's parameter 'tx_buffer_size' is set to zero: This function will not return until all the data and the break signal have been sent out. After all data is sent out, send a break signal.</p>
<p>Otherwise, if the 'tx_buffer_size' &gt; 0, this function will return after copying all the data to tx ring buffer, UART ISR will then move data from the ring buffer to TX FIFO gradually. After all data sent out, send a break signal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">src</td><td>data buffer address </td></tr>
    <tr><td class="paramname">size</td><td>data length to send </td></tr>
    <tr><td class="paramname">brk_len</td><td>break signal duration(unit: the time it takes to send one bit at current baudrate)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(-1) Parameter error</li>
<li>OTHERS (&gt;=0) The number of bytes pushed to the TX FIFO </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ada873c6deef1c1b23f76b3bc6e886339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada873c6deef1c1b23f76b3bc6e886339">&#9670;&nbsp;</a></span>uart_read_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int uart_read_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TickType_t&#160;</td>
          <td class="paramname"><em>ticks_to_wait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART read bytes from UART buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">buf</td><td>pointer to the buffer. </td></tr>
    <tr><td class="paramname">length</td><td>data length </td></tr>
    <tr><td class="paramname">ticks_to_wait</td><td>sTimeout, count in RTOS ticks</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(-1) Error</li>
<li>OTHERS (&gt;=0) The number of bytes read from UART FIFO </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1d6df979239b59c1d04ec3ef3db99127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6df979239b59c1d04ec3ef3db99127">&#9670;&nbsp;</a></span>uart_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias of uart_flush_input. UART ring buffer flush. This will discard all data in the UART RX buffer. </p>
<dl class="section note"><dt>Note</dt><dd>Instead of waiting the data sent out, this function will clear UART rx buffer. In order to send all the data in tx FIFO, we can use uart_wait_tx_done function. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a068def261085c0aea676689328e5a255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068def261085c0aea676689328e5a255">&#9670;&nbsp;</a></span>uart_flush_input()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_flush_input </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear input buffer, discard all the data is in the ring-buffer. </p>
<dl class="section note"><dt>Note</dt><dd>In order to send all the data in tx FIFO, we can use uart_wait_tx_done function. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a40f71f946b85f3029c6b21cb0ee320f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40f71f946b85f3029c6b21cb0ee320f9">&#9670;&nbsp;</a></span>uart_get_buffered_data_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_get_buffered_data_len </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART get RX ring buffer cached data length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART port number. </td></tr>
    <tr><td class="paramname">size</td><td>Pointer of size_t to accept cached data length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a8e37088bdce71c0137e52fd8b6786130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e37088bdce71c0137e52fd8b6786130">&#9670;&nbsp;</a></span>uart_disable_pattern_det_intr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_disable_pattern_det_intr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART disable pattern detect function. Designed for applications like 'AT commands'. When the hardware detects a series of one same character, the interrupt will be triggered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART port number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a7fcb877367ecf9b17e8f8380e7ded826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fcb877367ecf9b17e8f8380e7ded826">&#9670;&nbsp;</a></span>uart_enable_pattern_det_intr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_enable_pattern_det_intr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>pattern_chr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>chr_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>chr_tout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>post_idle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pre_idle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART enable pattern detect function. Designed for applications like 'AT commands'. When the hardware detect a series of one same character, the interrupt will be triggered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART port number. </td></tr>
    <tr><td class="paramname">pattern_chr</td><td>character of the pattern </td></tr>
    <tr><td class="paramname">chr_num</td><td>number of the character, 8bit value. </td></tr>
    <tr><td class="paramname">chr_tout</td><td>timeout of the interval between each pattern characters, 24bit value, unit is APB (80Mhz) clock cycle. When the duration is less than this value, it will not take this data as at_cmd char </td></tr>
    <tr><td class="paramname">post_idle</td><td>idle time after the last pattern character, 24bit value, unit is APB (80Mhz) clock cycle. When the duration is less than this value, it will not take the previous data as the last at_cmd char </td></tr>
    <tr><td class="paramname">pre_idle</td><td>idle time before the first pattern character, 24bit value, unit is APB (80Mhz) clock cycle. When the duration is less than this value, it will not take this data as the first at_cmd char</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a884eb8de9121304cce469cfa9292f0be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a884eb8de9121304cce469cfa9292f0be">&#9670;&nbsp;</a></span>uart_pattern_pop_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int uart_pattern_pop_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the nearest detected pattern position in buffer. The positions of the detected pattern are saved in a queue, this function will dequeue the first pattern position and move the pointer to next pattern position. </p>
<dl class="section note"><dt>Note</dt><dd>If the RX buffer is full and flow control is not enabled, the detected pattern may not be found in the rx buffer due to overflow. <pre class="fragment">   The following APIs will modify the pattern position info:
   uart_flush_input, uart_read_bytes, uart_driver_delete,
</pre> uart_pop_pattern_pos It is the application's responsibility to ensure atomic access to the pattern queue and the rx data buffer when using pattern detect feature.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART port number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(-1) No pattern found for current index or parameter error</li>
<li>others the pattern position in rx buffer. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a190fdc0b4d7b0e5e865b0cfb38383069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a190fdc0b4d7b0e5e865b0cfb38383069">&#9670;&nbsp;</a></span>uart_pattern_get_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int uart_pattern_get_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the nearest detected pattern position in buffer. The positions of the detected pattern are saved in a queue, This function do nothing to the queue. </p>
<dl class="section note"><dt>Note</dt><dd>If the RX buffer is full and flow control is not enabled, the detected pattern may not be found in the rx buffer due to overflow. <pre class="fragment">   The following APIs will modify the pattern position info:
   uart_flush_input, uart_read_bytes, uart_driver_delete,
</pre> uart_pop_pattern_pos It is the application's responsibility to ensure atomic access to the pattern queue and the rx data buffer when using pattern detect feature.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART port number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(-1) No pattern found for current index or parameter error</li>
<li>others the pattern position in rx buffer. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0e61a66fc42555cadd072adb907dd882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e61a66fc42555cadd072adb907dd882">&#9670;&nbsp;</a></span>uart_pattern_queue_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_pattern_queue_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queue_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new memory with the given length to save record the detected pattern position in rx buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART port number </td></tr>
    <tr><td class="paramname">queue_length</td><td>Max queue length for the detected pattern. If the queue length is not large enough, some pattern positions might be lost. Set this value to the maximum number of patterns that could be saved in data buffer at the same time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_ERR_NO_MEM No enough memory</li>
<li>ESP_ERR_INVALID_STATE Driver not installed</li>
<li>ESP_FAIL Parameter error</li>
<li>ESP_OK Success </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a950b10bb3fd5226fba28b633e92b4a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a950b10bb3fd5226fba28b633e92b4a53">&#9670;&nbsp;</a></span>uart_set_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_set_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a93f7c73d772490ab4d22bda8fd0aa5a6">uart_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART set communication mode. </p>
<dl class="section note"><dt>Note</dt><dd>This function must be executed after <a class="el" href="tesst_8h.html#af668e653f7b0af9dbf55cdb5be839ec9" title="Install UART driver. ">uart_driver_install()</a>, when the driver object is initialized. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>Uart number to configure </td></tr>
    <tr><td class="paramname">mode</td><td>UART UART mode to set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_ERR_INVALID_ARG Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a005d64fa971ebf3005e60f2adbf2fe0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a005d64fa971ebf3005e60f2adbf2fe0c">&#9670;&nbsp;</a></span>uart_set_rx_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_set_rx_timeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>tout_thresh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART set threshold timeout for TOUT feature. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>Uart number to configure </td></tr>
    <tr><td class="paramname">tout_thresh</td><td>This parameter defines timeout threshold in uart symbol periods. The maximum value of threshold is 126. tout_thresh = 1, defines TOUT interrupt timeout equal to transmission time of one symbol (~11 bit) on current baudrate. If the time is expired the UART_RXFIFO_TOUT_INT interrupt is triggered. If tout_thresh == 0, the TOUT feature is disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_ERR_INVALID_ARG Parameter error</li>
<li>ESP_ERR_INVALID_STATE Driver is not installed </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a010dea3538b131eb120886e92896de5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a010dea3538b131eb120886e92896de5d">&#9670;&nbsp;</a></span>uart_get_collision_flag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_get_collision_flag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>collision_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns collision detection flag for RS485 mode Function returns the collision detection flag into variable pointed by collision_flag. *collision_flag = true, if collision detected else it is equal to false. This function should be executed when actual transmission is completed (after <a class="el" href="tesst_8h.html#a4c2411719e618a486919676f592559e8" title="Send data to the UART port from a given buffer and length,. ">uart_write_bytes()</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>Uart number to configure </td></tr>
    <tr><td class="paramname">collision_flag</td><td>Pointer to variable of type bool to return collision flag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_ERR_INVALID_ARG Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a236f5ce8e193ce043cf6401201606f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a236f5ce8e193ce043cf6401201606f95">&#9670;&nbsp;</a></span>uart_set_wakeup_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_set_wakeup_threshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wakeup_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the number of RX pin signal edges for light sleep wakeup. </p>
<p>UART can be used to wake up the system from light sleep. This feature works by counting the number of positive edges on RX pin and comparing the count to the threshold. When the count exceeds the threshold, system is woken up from light sleep. This function allows setting the threshold value.</p>
<p>Stop bit and parity bits (if enabled) also contribute to the number of edges. For example, letter 'a' with ASCII code 97 is encoded as 0100001101 on the wire (with 8n1 configuration), start and stop bits included. This sequence has 3 positive edges (transitions from 0 to 1). Therefore, to wake up the system when 'a' is sent, set wakeup_threshold=3.</p>
<p>The character that triggers wakeup is not received by UART (i.e. it can not be obtained from UART FIFO). Depending on the baud rate, a few characters after that will also not be received. Note that when the chip enters and exits light sleep mode, APB frequency will be changing. To make sure that UART has correct baud rate all the time, select REF_TICK as UART clock source, by setting use_ref_tick field in <a class="el" href="structuart__config__t.html" title="UART configuration parameters for uart_param_config function. ">uart_config_t</a> to true.</p>
<dl class="section note"><dt>Note</dt><dd>in ESP32, the wakeup signal can only be input via IO_MUX (i.e. GPIO3 should be configured as function_1 to wake up UART0, GPIO9 should be configured as function_5 to wake up UART1), UART2 does not support light sleep wakeup feature.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART number </td></tr>
    <tr><td class="paramname">wakeup_threshold</td><td>number of RX edges for light sleep wakeup, value is 3 .. 0x3ff. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK on success</li>
<li>ESP_ERR_INVALID_ARG if uart_num is incorrect or wakeup_threshold is outside of [3, 0x3ff] range. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a12e939ff165ec4b92cb31fc31b0026d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e939ff165ec4b92cb31fc31b0026d0">&#9670;&nbsp;</a></span>uart_get_wakeup_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t uart_get_wakeup_threshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tesst_8h.html#a7f28644638bd57536eb5260695e83de9">uart_port_t</a>&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>out_wakeup_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of RX pin signal edges for light sleep wakeup. </p>
<p>See description of uart_set_wakeup_threshold for the explanation of UART wakeup feature.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">uart_num</td><td>UART number </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_wakeup_threshold</td><td>output, set to the current value of wakeup threshold for the given UART. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK on success</li>
<li>ESP_ERR_INVALID_ARG if out_wakeup_threshold is NULL </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon May 17 2021 11:19:28 for Edge node by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
